mod4 = glmer(Counting ~ Sham*Ipsi + (1|AnimalNo) + (1|Distance1), family=poisson,data = time1)
mod5 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), family=poisson,data = time1)
AIC(mod1,mod2,mod3,mod4,mod5)
dd2 <- dredge(mod2)
b2 <- get.models(dd2, 1)[[1]]
overdisp_fun(b2)
summary(b2)
mod2 = glmer.nb(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo/Distance1), data = time1)
mod2 = glmer.nb(Counting ~ Sham*Ipsi + (1|Distance1), data = time1)
overdisp_fun(mod2)
mod1 = glm.nb(Counting ~ Sham*Ipsi*Distance1, data = time1)
mod1 = glme.nb(Counting ~ Sham*Ipsi*Distance1, data = time1)
library(lme4)
library(MuMIn)
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp <- residuals(model,type="pearson")
Pearson.chisq <- sum(rp^2)
prat <- Pearson.chisq/rdf
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
data = read.csv("iba1.csv")
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
#data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
options(na.action = "na.fail")
#Time1
mod1 = glm(Counting ~ Sham*Ipsi*Distance1, family=poisson,data = time1)
mod2 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo/Distance1), family=poisson,data = time1)
mod3 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1+Distance1|AnimalNo), family=poisson,data = time1)
mod4 = glmer(Counting ~ Sham*Ipsi + (1|AnimalNo) + (1|Distance1), family=poisson,data = time1)
mod5 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), family=poisson,data = time1)
AIC(mod1,mod2,mod3,mod4,mod5)
dd2 <- dredge(mod2)
b2 <- get.models(dd2, 1)[[1]]
overdisp_fun(b2)
summary(b2)
mod1 = glme.nb(Counting ~ Sham*Ipsi*Distance1, data = time1)
mod1 = glm.nb(Counting ~ Sham*Ipsi*Distance1, data = time1)
mod1 = glm.nb(Counting ~ Sham*Ipsi*Distance1, data = time1)
mod1 = glm.nb(Counting ~ Sham*Ipsi*Distance1, data = time1)
#re-fit with negative binominal distribution
library(MASS)
mod1 = glm.nb(Counting ~ Sham*Ipsi*Distance1, data = time1)
mod2 = glmer.nb(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo/Distance1),data = time1)
mod3 = glmer.nb(Counting ~ Sham*Ipsi*Distance1 + (1+Distance1|AnimalNo),data = time1)
mod4 = glmer.nb(Counting ~ Sham*Ipsi + (1|AnimalNo) + (1|Distance1),data = time1)
mod5 = glmer.nb(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo),data = time1)
AIC(mod1,mod2,mod3,mod4,mod5)
dd2 <- dredge(mod4)
b2 <- get.models(dd2, 1)[[1]]
overdisp_fun(b2)
summary(mod2)
summary(b2)
#Time2
mod1 = glm(Counting ~ Sham*Ipsi*Distance1, family=poisson,data = time2)
mod2 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo/Distance1), family=poisson,data = time2)
mod3 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1+Distance1|AnimalNo), family=poisson,data = time2)
mod4 = glmer(Counting ~ Sham*Ipsi + (1|AnimalNo) + (1|Distance1), family=poisson,data = time2)
mod5 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), family=poisson,data = time2)
AIC(mod1,mod2,mod3,mod4,mod5)
dd2 <- dredge(mod2)
b2 <- get.models(dd2, 1)[[1]]
overdisp_fun(b2)
summary(b2)
#re-fit with negative binominal distribution
mod1 = glm.nb(Counting ~ Sham*Ipsi*Distance1, family=poisson,data = time2)
#re-fit with negative binominal distribution
mod1 = glm.nb(Counting ~ Sham*Ipsi*Distance1, data = time2)
mod2 = glmer.nb(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo/Distance1),data = time2)
mod3 = glmer.nb(Counting ~ Sham*Ipsi*Distance1 + (1+Distance1|AnimalNo),data = time2)
mod4 = glmer.nb(Counting ~ Sham*Ipsi + (1|AnimalNo) + (1|Distance1),data = time2)
mod5 = glmer.nb(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo),data = time2)
AIC(mod1,mod2,mod3,mod4,mod5)
dd2 <- dredge(mod1)
b2 <- get.models(dd2, 1)[[1]]
overdisp_fun(b2)
summary(b2)
#Time3
mod1 = glm(Counting ~ Sham*Ipsi*Distance1, family=poisson,data = time3)
mod2 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo/Distance1), family=poisson,data = time3)
mod3 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1+Distance1|AnimalNo), family=poisson,data = time3)
mod4 = glmer(Counting ~ Sham*Ipsi + (1|AnimalNo) + (1|Distance1), family=poisson,data = time3)
mod5 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), family=poisson,data = time3)
AIC(mod1,mod2,mod3,mod4,mod5)
dd2 <- dredge(mod2)
b2 <- get.models(dd2, 1)[[1]]
overdisp_fun(b2)
summary(b2)
plot(b2)
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
data
View(data)
View(data)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
time1$Intensity <- time1$Intensity/164.6666666
time2$Intensity <- time2$Intensity/141.55555555
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
time1$Intensity <- time1$Intensity/164.6666666
time1
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
time1$Intensity <- time1$Intensity
time2$Intensity <- time2$Intensity
time3$Intensity <- time3$Intensity
# Time 1
m.T1.int <- lmer(Intensity ~ Sham * Ipsi + (1|AnimalNo/Distance2),data = time1)
m.T1.add <- lmer(Intensity ~ Sham + Ipsi + (1|AnimalNo/Distance2),data = time1)
m.T1.sham <- lmer(Intensity ~ Sham + (1|AnimalNo/Distance2),data = time1)
m.T1.ipsi <- lmer(Intensity ~ Ipsi + (1|AnimalNo/Distance2),data = time1)
m.T1.null  = lmer(Intensity ~ 1 + (1|AnimalNo/Distance2),data = time1)
AIC(m.T1.int,m.T1.add,m.T1.sham,m.T1.ipsi,m.T1.null)# interaction model is the best
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
time1$Intensity <- time1$Intensity
time2$Intensity <- time2$Intensity
time3$Intensity <- time3$Intensity
# Time 1
m.T1.int <- lmer(Intensity ~ Sham * Ipsi + (1|AnimalNo/Distance2),data = time1)
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
time1$Counting <- time1$Counting
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
time1$Counting <- time1$Counting/164.666666666
time2$Counting <- time2$Counting/141.5555555555
time3$Counting <- time3$Counting/171.2
# Time 1
m.T1.int <- lmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance2),data = time1)
m.T1.add <- lmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance2),data = time1)
m.T1.sham <- lmer(Counting ~ Sham + (1|AnimalNo/Distance2),data = time1)
m.T1.ipsi <- lmer(Counting ~ Ipsi + (1|AnimalNo/Distance2),data = time1)
m.T1.null  = lmer(Counting ~ 1 + (1|AnimalNo/Distance2),data = time1)
AIC(m.T1.int,m.T1.add,m.T1.sham,m.T1.ipsi,m.T1.null)# interaction model is the best
# Then check whether the model fulfills the assumptions:
# residuals look very good
library(lattice)
trellis.par.set("background$col" = "white")
par(mar = rep(2, 4))
plot(m.T1.int)
qqnorm(residuals(m.T1.int))
qqline(residuals(m.T1.int))
#print confidence interval
summary(m.T1.int)
confint(m.T1.int) # not significant
# Time 2
m.T2.int <- lmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance2),data = time2)
m.T2.add <- lmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance2),data = time2)
m.T2.sham <- lmer(Counting ~ Sham + (1|AnimalNo/Distance2),data = time2)
m.T2.ipsi <- lmer(Counting ~ Ipsi + (1|AnimalNo/Distance2),data = time2)
m.T2.null  = lmer(Counting ~ 1 + (1|AnimalNo/Distance2),data = time2)
AIC(m.T2.int,m.T2.add,m.T2.sham,m.T2.ipsi,m.T2.null)# again: the interaction should be kept
plot(m.T2.int) # this looks ok
summary(m.T2.int) # stimulationa and the interaction with ipsi are significant. Please ignore the effects of distance in this case
confint(m.T2.int,level=0.995)
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
library(lme4)
# importin data
data = read.csv("iba1.csv")
# this is just to check whether evrything is imported correctly
# You need to specifiy certain variables as factors. R will think that they are on a continous
# Or interval scale, since they are registered as numbers. However, things like "sham"
# are clearly your treatment categories and you need to tell this to the program if you dont use
# letters for coding. The same with Random "FACTORS"
str(data)
head(data)
data$Time <- as.factor(data$Time) #
data$Sham <- as.factor(data$Sham) # this needs to be a factpr since it specifies your treatment categories
data$Ipsi <- as.factor(data$Ipsi) #
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)# also here, the animal are not a continous scale but separate identities
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
model_Time1 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time1)
model_Time2 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time2)
model_Time3 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time3)
library(lattice)
trellis.par.set("background$col" = "white")
# For Time 1 There are some animals which stick out. Based on the scatter, the distance might not have a large impact
xyplot(Counting ~ Distance1 | AnimalNo, pch = 16, cex = 1.3,
par.strip.text = list(cex = 1.5), scales = list(alternating = F), data=time1)
# For Time 2: very similar here
xyplot(Counting ~ Distance1 | AnimalNo, pch = 16, cex = 1.3,
par.strip.text = list(cex = 1.5), scales = list(alternating = F), data=time2)
# For Time 3: here might be a slight distance effect for only animal 22...
xyplot(Counting ~ Distance1 | AnimalNo, pch = 16, cex = 1.3,
par.strip.text = list(cex = 1.5), scales = list(alternating = F), data=time3)
# Time 1: it seems like the interaction model is the best way to describe your data!
m.T1.int <- glmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time1)
m.T1.add <- glmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time1)
m.T1.sham <- glmer(Counting ~ Sham + (1|AnimalNo/Distance1), family=poisson, data = time1)
m.T1.ipsi <- glmer(Counting ~ Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time1)
m.T1.null  = glmer(Counting ~ 1 + (1|AnimalNo/Distance1), family=poisson, data = time1)
AIC(m.T1.int,m.T1.add,m.T1.sham,m.T1.ipsi,m.T1.null)#
# Then check whether the model fulfills the assumptions:
# residuals look very good
plot(m.T1.int)
qqnorm(residuals(m.T1.int))
qqline(residuals(m.T1.int))
# in glms, you also have to check for over-dispersion
# Dispersion is a factor by which the variance is
# higher/lower than assumed by the model. A rough estimation of checking this is by dividing
# the residual deviance of the model by the degrees of freedom. The value should be between
# 0.6 and 2 (around 1). This was absolutely not fulfilled here and your model was highly
# ober-dispersed. You can also test this
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp <- residuals(model,type="pearson")
Pearson.chisq <- sum(rp^2)
prat <- Pearson.chisq/rdf
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
overdisp_fun(m.T1.int)
# The issue causes some difficulties, but the easiest way to deal with that is to
# assume a negative binomial distribution for your data, which assumes that the dispersion parameter
# can deviate from one.
m.T1.int.b <- glmer.nb(Counting ~ Sham * Ipsi +  (1|AnimalNo/Distance1),  data = time1) # for some reason, this model is over-fitted too. Maybe because the distance has to few levels to be properly estimated.
# I therefore included it as fixed effect, but then got other porblems. So I excluded the AnimalNo and kept Distance to somehow account for the unbalance here
m.T1.int.b <- glmer.nb(Counting ~ Sham * Ipsi +  (1|Distance1),  data = time1)
plot(m.T1.int.b) # now the assumptions look good
qqnorm(residuals(m.T1.int.b))
qqline(residuals(m.T1.int.b))
# then you can extract the effect strengths on link scale (log): you can use these to judge stat significance
summary(m.T1.int.b) #
confint(m.T1.int.b) # these are the 95% CIs. It corresponds to the p values in the summary () output
# You can get the estimated counts (response scale) from your model using the effects package
library(effects)
eff.T1 <- allEffects(m.T1.int.b)# These are the effects on response scale, meaning the counts
plot(eff.T1)# you can also extract the effects and their confidence intervals. Just check what the package has to offer
# Time 2: same here, interaction term is important
m.T2.int <- glmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time2)
m.T2.add <- glmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time2)
m.T2.sham <- glmer(Counting ~ Sham + (1|AnimalNo/Distance1), family=poisson, data = time2)
m.T2.ipsi <- glmer(Counting ~ Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time2)
m.T2.null  = glmer(Counting ~ 1 + (1|AnimalNo/Distance1), family=poisson, data = time2)
AIC(m.T2.int,m.T2.add,m.T2.sham,m.T2.ipsi,m.T2.null)# again: the interaction should be kept
overdisp_fun(m.T2.int) # we fit the negative binomial version again
m.T2.int.b <- glmer.nb(Counting ~ Sham * Ipsi +  (1|AnimalNo/Distance1),  data = time2) # same issue as for T1
m.T2.int.b <- glmer.nb(Counting ~ Distance1 +Sham * Ipsi +  (1|AnimalNo),  data = time2) # this solution does not work in this case. I dropped the random effects and used the distance as fixed co-variate
library(MASS)
m.T2.int.b <- glm.nb(Counting ~ Distance1 +Sham * Ipsi,  data = time2) #
plot(m.T2.int.b) # we should remove point 105 as an outlier
m.T2.int.b <- glm.nb(Counting ~ Distance1 +Sham * Ipsi,  data = time2.b) #
plot(m.T2.int.b) # this looks ok
confint(m.T2.int.b)
eff.T2 <- allEffects(m.T2.int)#
plot(eff.T2)
# Time 3: here the interaction is significant too!
m.T3.int <- glmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time3)
summary(m.T2.int.b) # stimulationa and the interaction with ipsi are significant. Please ignore the effects of distance in this case
m.T2.int.b <- glm.nb(Counting ~ Distance1 +Sham * Ipsi,  data = time2.b) #
summary(m.T2.int.b) # stimulationa and the interaction with ipsi are significant. Please ignore the effects of distance in this case
confint(m.T2.int.b)
summary(m.T2.int.b) # stimulationa and the interaction with ipsi are significant. Please ignore the effects of distance in this case
confint(m.T2.int.b)
confint(m.T2.int.bï¼Œlevel=0.995)
eff.T2 <- allEffects(m.T2.int)#
library(lme4)
# importin data
data = read.csv("iba1.csv")
# specifiy certain variables as factors
str(data)
head(data)
data$Time <- as.factor(data$Time)
data$Sham <- as.factor(data$Sham)
data$Ipsi <- as.factor(data$Ipsi)
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
time1$Counting <- time1$Counting
time2$Counting <- time2$Counting
library(lme4)
# importin data
data = read.csv("iba1.csv")
# this is just to check whether evrything is imported correctly
# You need to specifiy certain variables as factors. R will think that they are on a continous
# Or interval scale, since they are registered as numbers. However, things like "sham"
# are clearly your treatment categories and you need to tell this to the program if you dont use
# letters for coding. The same with Random "FACTORS"
str(data)
head(data)
data$Time <- as.factor(data$Time) #
data$Sham <- as.factor(data$Sham) # this needs to be a factpr since it specifies your treatment categories
data$Ipsi <- as.factor(data$Ipsi) #
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)# also here, the animal are not a continous scale but separate identities
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
model_Time1 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time1)
model_Time2 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time2)
model_Time3 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time3)
library(lattice)
library(lme4)
# importin data
data = read.csv("iba1.csv")
# this is just to check whether evrything is imported correctly
# You need to specifiy certain variables as factors. R will think that they are on a continous
# Or interval scale, since they are registered as numbers. However, things like "sham"
# are clearly your treatment categories and you need to tell this to the program if you dont use
# letters for coding. The same with Random "FACTORS"
str(data)
head(data)
data$Time <- as.factor(data$Time) #
data$Sham <- as.factor(data$Sham) # this needs to be a factpr since it specifies your treatment categories
data$Ipsi <- as.factor(data$Ipsi) #
data$Distance2 <- as.factor(data$Distance2)
data$Distance1 <- as.factor(data$Distance1)
data$AnimalNo <- as.factor(data$AnimalNo)# also here, the animal are not a continous scale but separate identities
time1 <- as.data.frame(data[data$Time=="1",])
time2 <- as.data.frame(data[data$Time=="2",])
time3 <- as.data.frame(data[data$Time=="3",])
model_Time1 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time1)
model_Time2 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time2)
model_Time3 = glmer(Counting ~ Sham*Ipsi*Distance1 + (1|AnimalNo), data = time3)
library(lattice)
trellis.par.set("background$col" = "white")
# For Time 1 There are some animals which stick out. Based on the scatter, the distance might not have a large impact
xyplot(Counting ~ Distance1 | AnimalNo, pch = 16, cex = 1.3,
par.strip.text = list(cex = 1.5), scales = list(alternating = F), data=time1)
# For Time 2: very similar here
xyplot(Counting ~ Distance1 | AnimalNo, pch = 16, cex = 1.3,
par.strip.text = list(cex = 1.5), scales = list(alternating = F), data=time2)
# For Time 3: here might be a slight distance effect for only animal 22...
xyplot(Counting ~ Distance1 | AnimalNo, pch = 16, cex = 1.3,
par.strip.text = list(cex = 1.5), scales = list(alternating = F), data=time3)
# Time 1: it seems like the interaction model is the best way to describe your data!
m.T1.int <- glmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time1)
m.T1.add <- glmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance1), family=poisson, data = time1)
# Time 1: it seems like the interaction model is the best way to describe your data!
m.T1.int <- glmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time1)
m.T1.add <- glmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time1)
m.T1.sham <- glmer(Counting ~ Sham + (1|AnimalNo/Distance2), family=poisson, data = time1)
m.T1.ipsi <- glmer(Counting ~ Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time1)
m.T1.null  = glmer(Counting ~ 1 + (1|AnimalNo/Distance2), family=poisson, data = time1)
AIC(m.T1.int,m.T1.add,m.T1.sham,m.T1.ipsi,m.T1.null)#
# Then check whether the model fulfills the assumptions:
# residuals look very good
plot(m.T1.int)
qqnorm(residuals(m.T1.int))
qqline(residuals(m.T1.int))
# in glms, you also have to check for over-dispersion
# Dispersion is a factor by which the variance is
# higher/lower than assumed by the model. A rough estimation of checking this is by dividing
# the residual deviance of the model by the degrees of freedom. The value should be between
# 0.6 and 2 (around 1). This was absolutely not fulfilled here and your model was highly
# ober-dispersed. You can also test this
overdisp_fun <- function(model) {
rdf <- df.residual(model)
rp <- residuals(model,type="pearson")
Pearson.chisq <- sum(rp^2)
prat <- Pearson.chisq/rdf
pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
overdisp_fun(m.T1.int)
# The issue causes some difficulties, but the easiest way to deal with that is to
# assume a negative binomial distribution for your data, which assumes that the dispersion parameter
# can deviate from one.
m.T1.int.b <- glmer.nb(Counting ~ Sham * Ipsi +  (1|AnimalNo/Distance2),  data = time1) # for some reason, this model is over-fitted too. Maybe because the distance has to few levels to be properly estimated.
# I therefore included it as fixed effect, but then got other porblems. So I excluded the AnimalNo and kept Distance to somehow account for the unbalance here
m.T1.int.b <- glmer.nb(Counting ~ Sham * Ipsi +  (1|Distance2),  data = time1)
plot(m.T1.int.b) # now the assumptions look good
qqnorm(residuals(m.T1.int.b))
qqline(residuals(m.T1.int.b))
# then you can extract the effect strengths on link scale (log): you can use these to judge stat significance
summary(m.T1.int.b) #
confint(m.T1.int.b) # these are the 95% CIs. It corresponds to the p values in the summary () output
# You can get the estimated counts (response scale) from your model using the effects package
library(effects)
eff.T1 <- allEffects(m.T1.int.b)# These are the effects on response scale, meaning the counts
eff.T1
plot(eff.T1)# you can also extract the effects and their confidence intervals. Just check what the package has to offer
# Time 2: same here, interaction term is important
m.T2.int <- glmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time2)
m.T2.add <- glmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time2)
m.T2.sham <- glmer(Counting ~ Sham + (1|AnimalNo/Distance2), family=poisson, data = time2)
m.T2.ipsi <- glmer(Counting ~ Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time2)
m.T2.null  = glmer(Counting ~ 1 + (1|AnimalNo/Distance2), family=poisson, data = time2)
AIC(m.T2.int,m.T2.add,m.T2.sham,m.T2.ipsi,m.T2.null)# again: the interaction should be kept
overdisp_fun(m.T2.int) # we fit the negative binomial version again
m.T2.int.b <- glmer.nb(Counting ~ Sham * Ipsi +  (1|AnimalNo/Distance2),  data = time2) # same issue as for T1
m.T2.int.b <- glmer.nb(Counting ~ Distance1 +Sham * Ipsi +  (1|AnimalNo),  data = time2) # this solution does not work in this case. I dropped the random effects and used the distance as fixed co-variate
m.T2.int.b <- glmer.nb(Counting ~ Distance1 +Sham * Ipsi +  (1|AnimalNo),  data = time2) # this solution does not work in this case. I dropped the random effects and used the distance as fixed co-variate
library(MASS)
m.T2.int.b <- glm.nb(Counting ~ Distance1 +Sham * Ipsi,  data = time2) #
plot(m.T2.int.b) # we should remove point 105 as an outlier
m.T2.int.b <- glm.nb(Counting ~ Distance1 +Sham * Ipsi,  data = time2.b) #
plot(m.T2.int.b) # this looks ok
confint(m.T2.int.b)
summary(m.T2.int.b) # stimulationa and the interaction with ipsi are significant. Please ignore the effects of distance in this case
confint(m.T2.int.b)
eff.T2 <- allEffects(m.T2.int)#
plot(eff.T2)
# Time 3: here the interaction is significant too!
m.T3.int <- glmer(Counting ~ Sham * Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time3)
m.T3.add <- glmer(Counting ~ Sham + Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time3)
m.T3.sham <- glmer(Counting ~ Sham + (1|AnimalNo/Distance2), family=poisson, data = time3)
m.T3.ipsi <- glmer(Counting ~ Ipsi + (1|AnimalNo/Distance2), family=poisson, data = time3)
m.T3.null  = glmer(Counting ~ 1 + (1|AnimalNo/Distance2), family=poisson, data = time3)
AIC(m.T3.int,m.T3.add,m.T3.sham,m.T3.ipsi,m.T3.null)#
overdisp_fun(m.T3.int) # also here, we assume a negative binomial dist
m.T3.int.b <- glmer.nb(Counting ~ Sham * Ipsi +  (1|AnimalNo/Distance2),  data = time3) # we have the same problems as for model Time2
m.T3.int.b <- glm.nb(Counting ~ Distance1 +Sham * Ipsi,  data = time3) #
plot(m.T3.int.b) # I removed point 338
data2 <- as.data.frame(data[-338,])
time3.b <- as.data.frame(data2[data2$Time=="3",])
m.T3.int.b <- glm.nb(Counting ~ Sham * Ipsi,  data = time3.b) #
plot(m.T3.int.b) # looks good now
summary(m.T3.int.b) #
confint(m.T3.int.b)
confint(m.T3.int.b,level=0.995)
